### `users` # rbac
(`user_id`, `full_name`, `email`, `password`, `positive_reviews`, `negative_reviews`, `status`, `password_updated_at`, `failed_login_attempts`, `last_login_at`, `created_at`)

* **Data Type:** `user_id` (INT), `full_name` (VARCHAR), `email` (VARCHAR), `password` (VARCHAR - Hash), `positive_reviews` (INT), `negative_reviews` (INT), `status` (ENUM('pending_verification', 'active', 'pending_upgrade', 'suspended')), `password_updated_at` (TIMESTAMP), `failed_login_attempts` (INT), `last_login_at` (TIMESTAMP), `created_at` (TIMESTAMP)
* **PK:** `user_id`
* **FK:** (None)
* **Constraint:**
    * `full_name`: NOT NULL
    * `email`: NOT NULL, UNIQUE
    * `password`: NOT NULL
    * `positive_reviews`: NOT NULL, DEFAULT 0
    * `negative_reviews`: NOT NULL, DEFAULT 0
    * `status`: NOT NULL, DEFAULT 'pending_verification'
    * `password_updated_at`: Nullable
    * `failed_login_attempts`: NOT NULL, DEFAULT 0
    * `last_login_at`: Nullable
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP

---

### `roles` # rbac
(`role_id`, `name`)

* **Data Type:** `role_id` (INT), `name` (VARCHAR)
* **PK:** `role_id`
* **FK:** (Không có)
* **Constraint:** `name` (NOT NULL, UNIQUE)

---

### `permissions` # rbac
(`permission_id`, `name`)

* **Data Type:** `permission_id` (INT), `name` (VARCHAR)
* **PK:** `permission_id`
* **FK:** (Không có)
* **Constraint:** `name` (NOT NULL, UNIQUE)

---

### `users_roles` # rbac
(`user_id`, `role_id`)

* **Data Type:** `user_id` (INT), `role_id` (INT)
* **PK:** `PRIMARY KEY (user_id, role_id)` (PK kép)
* **FK:**
    * `user_id` $\rightarrow$ `users(user_id)`
    * `role_id` $\rightarrow$ `roles(role_id)`
* **Constraint:** (Không có)

---

### `roles_permissions` # rbac
(`role_id`, `permission_id`)

* **Data Type:** `role_id` (INT), `permission_id` (INT)
* **PK:** `PRIMARY KEY (role_id, permission_id)` (PK kép)
* **FK:**
    * `role_id` $\rightarrow$ `roles(role_id)`
    * `permission_id` $\rightarrow$ `permissions(permission_id)`
* **Constraint:** (Không có)

---

### `categories`
(`category_id`, `name`, `slug`, `parent_id`)

* **Data Type:** `category_id` (INT), `name` (VARCHAR), `slug` (VARCHAR), `parent_id` (INT)
* **PK:** `category_id`
* **FK:** `parent_id` → `categories(category_id)` ON DELETE RESTRICT
* **Constraint in DB:**
    * `name`: NOT NULL
    * `parent_id`: Nullable
    * `slug`: NOT NULL
    * `UNIQUE(parent_id, slug)` - a category with different parent can have the same slug
    * `CHECK (parent_id IS NULL OR parent_id != category_id)` - prevent self-reference
    * `ck_category_two_levels`: CHECK that parent must be root (parent_id IN (SELECT category_id WHERE parent_id IS NULL))
* **Constraint in Application:**
    * Only 2 levels allowed: root (parent_id = NULL) and child (parent_id != NULL)
    * A child category must have a parent with parent_id = NULL (cannot be grandchild)
    * Validate max depth = 2 when inserting/updating
* **Trigger:**
    * `auto_generate_slug()` when inserting and updating
* **Notes:**
    * What is a slug? Read document: https://itnext.io/whats-a-slug-f7e74b6c23e0
    * **ON DELETE RESTRICT** prevents deletion of category if it has products (enforced by FK from products table)
    * **ck_category_two_levels** ensures only 2-level hierarchy: parent categories must be root (no grandchildren allowed)

---

### `products`
(`product_id`, `category_id`, `seller_id`, `highest_bidder_id`, `name`, `thumbnail_url`, `current_price`, `buy_now_price`, `start_price`, `step_price`, `created_at`, `end_time`, `bid_count`, `auto_extend`, `status`, `fts`)

* **Data Type:** `product_id` (INT), `category_id` (INT), `seller_id` (INT), `highest_bidder_id` (INT), `name` (VARCHAR), `thumbnail_url` (VARCHAR), `current_price` (DECIMAL), `buy_now_price` (DECIMAL), `start_price` (DECIMAL), `step_price` (DECIMAL), `created_at` (TIMESTAMP), `end_time` (TIMESTAMP), `bid_count` (INT), `auto_extend` (BOOLEAN), `status` (ENUM('active', 'sold', 'expired', 'removed')), `fts` (TSVECTOR - PostgreSQL only)
* **PK:** `product_id`
* **FK:**
    * `category_id` → `categories(category_id)` ON DELETE RESTRICT
    * `seller_id` → `users(user_id)`
    * `highest_bidder_id` → `users(user_id)`
* **Constraint in DB:**
    * `highest_bidder_id`: Nullable
    * `name`: NOT NULL
    * `thumbnail_url`: Nullable
    * `current_price`: NOT NULL
    * `buy_now_price`: Nullable
    * `start_price`: NOT NULL
    * `step_price`: NOT NULL
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP
    * `end_time`: NOT NULL
    * `bid_count`: NOT NULL, DEFAULT 0
    * `auto_extend`: NOT NULL, DEFAULT false
    * `status`: NOT NULL, DEFAULT 'active'
    * `fts`: Nullable (auto-generated by trigger)
    * `CHECK (end_time > created_at)`
    * `CHECK (step_price > 0)`
    * `CHECK (start_price > 0)`
    * `CHECK (current_price >= start_price)`
    * `CHECK (buy_now_price IS NULL OR buy_now_price >= start_price)`
* **Constraint in Application:**
    * Cannot bid if `CURRENT_TIMESTAMP > end_time`
    * Cannot bid if `status != 'active'`
    * Cannot bid if `seller_id = bidder_id` (prevent self-bidding)
    * New bid amount must be `>= current_price + step_price`
* **Index:**
    * INDEX (status, end_time) - for listing active products sorted by end time
    * INDEX (category_id, status) - for category filtering
    * INDEX GIN(fts) - for full-text search (PostgreSQL)
* **Trigger:**
    * `update_product_on_bid` - updates current_price, highest_bidder_id, bid_count when new bid inserted
    * `auto_extend_auction` - extends end_time if bid placed within threshold (see system_settings)
    * `products_fts_update()` - auto-updates FTS column combining product name (weight A), latest description content (weight B), and category name (weight C) for full-text search
* **Notes:**
    * **fts column (TSVECTOR)**: Used for full-text search functionality (requirement 1.4). Auto-updated by trigger when product name or category changes.
    * **FTS Trigger**: Combines weighted tsvectors - product.name (highest weight 'A'), latest product_description.content (weight 'B'), category.name (weight 'C')
    * **ON DELETE RESTRICT**: FK to categories prevents deletion of category with existing products (requirement 4.1)

---

### `auto_bids`
(`auto_bid_id`, `product_id`, `bidder_id`, `max_amount`, `created_at`)

* **Data Type:** `auto_bid_id` (INT), `product_id` (INT), `bidder_id` (INT), `max_amount` (DECIMAL), `created_at` (TIMESTAMP)
* **PK:** `auto_bid_id`
* **FK:**
    * `product_id` → `products(product_id)`
    * `bidder_id` → `users(user_id)`
* **Constraint in DB:**
    * `max_amount`: NOT NULL, CHECK (max_amount > 0)
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP
    * `UNIQUE (product_id, bidder_id)`
* **Constraint in Application:**
    * `max_amount` must be >= product.current_price + product.step_price
    * Cannot auto-bid on own product (seller_id != bidder_id)
    * Check bidder rating >= 80% or seller allows unrated bidders
* **Index:**
    * INDEX (product_id, created_at ASC) - tie-breaker for equal max amounts (earlier bid wins)

---

### `bids`
(`bid_id`, `product_id`, `bidder_id`, `amount`, `is_auto`, `created_at`)

* **Data Type:** `bid_id` (INT), `product_id` (INT), `bidder_id` (INT), `amount` (DECIMAL), `is_auto` (BOOLEAN), `created_at` (TIMESTAMP)
* **PK:** `bid_id`
* **FK:**
    * `product_id` → `products(product_id)`
    * `bidder_id` → `users(user_id)`
* **Constraint in DB:**
    * `amount`: NOT NULL, CHECK (amount > 0)
    * `is_auto`: NOT NULL, DEFAULT false
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP
* **Constraint in Application:**
    * `amount` must be >= product.current_price + product.step_price
    * Cannot bid if bidder is in product_rejections for this product
    * Check bidder rating >= 80% or seller allows unrated bidders
    * Cannot bid on expired products (CURRENT_TIMESTAMP <= end_time)
    * Cannot bid on own product (seller_id != bidder_id)
* **Index:**
    * INDEX (product_id, created_at DESC) - fast query bid history by product
    * INDEX (bidder_id) - query bid history by bidder
* **Trigger:**
    * `update_product_on_bid_insert` - updates products.current_price, products.highest_bidder_id, products.bid_count
    * `auto_extend_on_late_bid` - extends products.end_time if bid within auto_extend_threshold minutes

---

### `product_descriptions`
(`description_id`, `product_id`, `author_id`, `content`, `lang`, `version`, `created_at`)

* **Data Type:** `description_id` (INT), `product_id` (INT), `author_id` (INT), `content` (TEXT), `lang` (VARCHAR), `version` (INT), `created_at` (TIMESTAMP)
* **PK:** `description_id`
* **FK:**
    * `product_id` → `products(product_id)`
    * `author_id` → `users(user_id)`
* **Constraint in DB:**
    * `content`: NOT NULL
    * `author_id`: NOT NULL
    * `lang`: NOT NULL, DEFAULT 'en'
    * `version`: NOT NULL, DEFAULT 1
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP
    * `UNIQUE (product_id, version)` - ensures version uniqueness per product
* **Constraint in Application:**
    * Append-only: Cannot update existing descriptions, only INSERT new version
    * `version` = MAX(version) + 1 for the product
    * Display all versions in chronological order (append style)

---

### `product_images`
(`image_id`, `product_id`, `image_url`)

* **Data Type:** `image_id` (INT), `product_id` (INT), `image_url` (VARCHAR)
* **PK:** `image_id`
* **FK:** `product_id` $\rightarrow$ `products(product_id)`
* **Constraint:** `image_url` (NOT NULL)

---

### `watchlist`
(`user_id`, `product_id`)

* **Data Type:** `user_id` (INT), `product_id` (INT)
* **PK:** `PRIMARY KEY (user_id, product_id)` (Composite PK)
* **FK:**
    * `user_id` → `users(user_id)`
    * `product_id` → `products(product_id)`
* **Constraint:** (None)

---

### `product_rejections`
(`rejection_id`, `product_id`, `bidder_id`, `reason`, `created_at`)

* **Data Type:** `rejection_id` (INT), `product_id` (INT), `bidder_id` (INT), `reason` (TEXT), `created_at` (TIMESTAMP)
* **PK:** `rejection_id`
* **FK:**
    * `product_id` → `products(product_id)`
    * `bidder_id` → `users(user_id)`
* **Constraint in DB:**
    * `reason`: Nullable
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP
    * `UNIQUE (product_id, bidder_id)`
* **Constraint in Application:**
    * Can only reject bidder who has at least 1 bid on this product
    * If rejected bidder is current highest_bidder, move to second highest bidder
* **Trigger:**
    * `reassign_highest_bidder_on_rejection` - if rejected bidder is highest, find next highest valid bidder

---

### `product_comments`
(`comment_id`, `product_id`, `user_id`, `content`, `parent_id`, `created_at`)

* **Date Type:** `comment_id` (INT), `product_id` (INT), `user_id` (INT),`content` (TEXT), `parent_id` (INT), `created_at` (TIMESTAMP), updated_at(TIMESTAMP)
* **PK:** `comment_id`
* **FK:** 
    * `product_id` → `products(product_id)`
    * `user_id` → `users(user_id)`
    * `parent_id` → `product_comments(comment_id)`

* **Constraint:**
    * `content`: NOT NULL
    * `parent_id`: Nullable
    * `created_at`: NOT NULL, DEFAULT CURRENT_STAMP
    * `updated_at`: Nullable

---

### `orders`
(`order_id`, `product_id`, `winner_id`, `seller_id`, `final_price`, `status`, `cancellation_reason`, `created_at`)

* **Data Type:** `order_id` (INT), `product_id` (INT), `winner_id` (INT), `seller_id` (INT), `final_price` (DECIMAL), `status` (ENUM('pending', 'contract_provided', 'payment_confirmed', 'shipped', 'completed', 'cancelled')), `cancellation_reason` (TEXT), `created_at` (TIMESTAMP)
* **PK:** `order_id`
* **FK:**
    * `product_id` → `products(product_id)`
    * `winner_id` → `users(user_id)`
    * `seller_id` → `users(user_id)`
* **Constraint:**
    * `product_id`: UNIQUE
    * `final_price`: NOT NULL
    * `status`: NOT NULL, DEFAULT 'pending'
    * `cancellation_reason`: Nullable
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP 

---

### `invoices`
(invoice_id, order_id, shipping_address, payment_proof_url, shipping_tracking_code, created_at)

* **Data Type:**
    * `invoice_id` (INT, PK)
    * `order_id` (INT, FK -> orders, UNIQUE)
    * `shipping_address` (TEXT, Nullable)     
    * `payment_proof_url` (VARCHAR, Nullable) 
    * `shipping_tracking_code` (VARCHAR, Nullable) 
    * `created_at` (TIMESTAMP)
    * `updated_at` (TIMESTAMP)
* **PK:** `invoice_id`
* **FK:** `order_id` → `orders(order_id)`
* **Constraint:**
    * order_id: UNIQUE (Rất quan trọng, để đảm bảo mối quan hệ 1-1 với bảng orders).
    * shipping_address: Nullable (Cho phép NULL).
    * payment_proof_url: Nullable (Cho phép NULL).
    * shipping_tracking_code: Nullable (Cho phép NULL).
    * created_at: NOT NULL, DEFAULT CURRENT_TIMESTAMP

---

### `reviews`
(`review_id`, `order_id`, `reviewer_id`, `reviewered_id`, `rating`, `content`, `created_at`, `updated_at`)

* **Data Type:** `review_id` (INT), `order_id` (INT), `reviewer_id` (INT), `reviewered_id` (INT), `rating` (INT), `content` (TEXT), `created_at` (TIMESTAMP), `updated_at` (TIMESTAMP)
* **PK:** `review_id`
* **FK:**
    * `order_id` → `orders(order_id)`
    * `reviewer_id` → `users(user_id)`
    * `reviewered_id` → `users(user_id)`
* **Constraint in DB:**
    * `rating`: NOT NULL, CHECK (rating = 1 OR rating = -1)
    * `content`: Nullable
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP
    * `updated_at`: Nullable
    * `UNIQUE (order_id, reviewer_id, reviewered_id)` - each review direction only has 1 record
* **Constraint in Application:**
    * Can only review if order.status = 'completed' OR 'cancelled'
    * Reviewer must be either order.winner_id or order.seller_id
    * Reviewered must be the other party (winner reviews seller, seller reviews winner)
    * Allow updating rating/content (updated_at tracks changes)
* **Trigger:**
    * `update_user_rating_on_review_insert` - increment users.positive_reviews or negative_reviews
    * `update_user_rating_on_review_update` - adjust counters if rating changed from +1 to -1 or vice versa

---

### `user_otps`
(`otp_id`, `user_id`, `otp_code`, `purpose`, `expires_at`, `consumed_at`)

* **Data Type:** `otp_id` (INT), `user_id` (INT), `otp_code` (VARCHAR), `purpose` (ENUM('signup', 'reset_password', 'other')), `created_at` (TIMESTAMP), `expires_at` (TIMESTAMP), `consumed_at` (TIMESTAMP)
* **PK:** `otp_id`
* **FK:** `user_id` → `users(user_id)`
* **Constraint:**
    * `otp_code`: NOT NULL
    * `purpose`: NOT NULL
    * `expires_at`: NOT NULL
    * `consumed_at`: Nullable
    * `UNIQUE (user_id, purpose) WHERE consumed_at IS NULL` - only one active OTP per purpose

---

### `upgrade_requests`
(`request_id`, `user_id`, `status`, `created_at`, `approved_at`, `expires_at`)

* **Data Type:** `request_id` (INT), `user_id` (INT), `status` (ENUM('pending', 'approved', 'rejected')), `created_at` (TIMESTAMP), `approved_at` (TIMESTAMP), `expires_at` (TIMESTAMP)
* **PK:** `request_id`
* **FK:** `user_id` → `users(user_id)`
* **Constraint:**
    * `status`: NOT NULL, DEFAULT 'pending'
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP
    * `approved_at`: Nullable
    * `expires_at`: Nullable, DEFAULT (created_at + INTERVAL '7 days')
* **Constraint in Application:**
    * Admin should process request within 7 days (expires_at)
    * Expired requests can be auto-rejected or require re-submission
* **Notes:**
    * **expires_at**: Tracks 7-day approval window for bidder → seller upgrades (requirement 2.6)
    * After approval, user status changes from 'pending_upgrade' to 'active' and gains seller role

---

### `order_chat`
(`message_id`, `order_id`, `sender_id`, `receiver_id`, `content`, `created_at`)

* **Data Type:** `message_id` (INT), `order_id` (INT), `sender_id` (INT), `receiver_id` (INT), `content` (TEXT), `created_at` (TIMESTAMP)
* **PK:** `message_id`
* **FK:**
    * `order_id` → `orders(order_id)`
    * `sender_id` → `users(user_id)`
    * `receiver_id` → `users(user_id)`
* **Constraint:**
    * `content`: NOT NULL
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP

---

### `notifications`
(`notification_id`, `user_id`, `type`, `channel`, `content`, `is_read`, `read_at`, `action_url`, `created_at`)

* **Data Type:** `notification_id` (INT), `user_id` (INT), `type` (VARCHAR), `channel` (ENUM('email', 'in_app')), `content` (TEXT), `is_read` (BOOLEAN), `read_at` (TIMESTAMP), `action_url` (VARCHAR(255)), `created_at` (TIMESTAMP)
* **PK:** `notification_id`
* **FK:** `user_id` → `users(user_id)`
* **Constraint:**
    * `type`: NOT NULL
    * `channel`: NOT NULL, DEFAULT 'in_app'
    * `content`: NOT NULL
    * `is_read`: NOT NULL, DEFAULT false
    * `read_at`: Nullable
    * `action_url`: Nullable
    * `created_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP
* **Index:**
    * INDEX (user_id, is_read, created_at DESC) - fast query unread notifications

---

### `system_settings`
(`setting_key`, `setting_value`, `description`, `updated_at`)

* **Data Type:** `setting_key` (VARCHAR(50)), `setting_value` (VARCHAR(255)), `description` (TEXT), `updated_at` (TIMESTAMP)
* **PK:** `setting_key`
* **FK:** (None)
* **Constraint:**
    * `setting_key`: NOT NULL
    * `setting_value`: NOT NULL
    * `description`: Nullable
    * `updated_at`: NOT NULL, DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
* **Initial Data:**
    * ('auto_extend_threshold_minutes', '5', 'Time threshold in minutes before auction end to trigger auto-extend')
    * ('auto_extend_duration_minutes', '10', 'Duration in minutes to extend auction when triggered')
    * ('new_product_highlight_minutes', '60', 'Products posted within N minutes are highlighted as NEW')
    * ('min_rating_percentage', '80', 'Minimum rating percentage (0-100) required to bid')
* **Notes:**
    * Admin can update these settings via admin panel
    * Application reads these values for business logic (auto-extend, rating checks, etc.)